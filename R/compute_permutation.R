#' Compute permutation-based p-values for annotation scores
#'
#' @description
#' Performs permutation testing to assess the statistical significance of
#' annotation scores. The null distribution is generated by permuting the
#' m/z values across peaks, which breaks the true peak-compound relationships
#' while maintaining the overall m/z distribution.
#'
#' @param annotation Data frame with annotation results including scores
#' @param peak_table Peak table with mz, rt columns
#' @param compound_table Compound database
#' @param adduct_table Adduct table for mass matching
#' @param mass_tolerance Mass tolerance for matching (default 5e-6 = 5 ppm)
#' @param n_permutations Number of permutations (default 1000)
#' @param seed Random seed for reproducibility
#' @param n_cores Number of cores for parallel processing
#' @param method Permutation method: "full" (default, all permutations in parallel),
#'   or "streaming" (memory-efficient, processes in chunks)
#' @return Data frame with perm_pvalue column added
#' @export
compute_permutation_pvalues <- function(annotation,
                                        peak_table,
                                        compound_table,
                                        adduct_table,
                                        mass_tolerance = 5e-6,
                                        n_permutations = 1000,
                                        seed = 42,
                                        n_cores = 1,
                                        method = "full") {
  set.seed(seed)

  observed_scores <- annotation$score
  n_annotations <- nrow(annotation)

  message(sprintf("=== Computing Permutation P-values ==="))
  message(sprintf("Permutations: %d, Cores: %d, Method: %s",
                  n_permutations, n_cores, method))

  # Function to run single permutation (wrapped in tryCatch for parallel safety)
  run_permutation <- function(perm_id) {
    tryCatch({
      permuted_peaks <- peak_table
      permuted_peaks$mz <- sample(permuted_peaks$mz)

      null_annotation <- simple_annotation(
        peak_table = permuted_peaks,
        compound_table = compound_table,
        adduct_table = adduct_table,
        mass_tolerance = mass_tolerance
      )

      # Match scores back to original annotation rows
      null_scores <- rep(0, n_annotations)
      if (nrow(null_annotation) > 0 && "score" %in% names(null_annotation)) {
        for (i in seq_len(n_annotations)) {
          peak_id <- annotation$mz[i]
          matched <- null_annotation[abs(null_annotation$mz - peak_id) < 1e-6, ]
          if (nrow(matched) > 0) {
            null_scores[i] <- max(matched$score, na.rm = TRUE)
          }
        }
      }
      return(null_scores)
    }, error = function(e) {
      return(NULL)
    })
  }


  # Validate method parameter

  method <- match.arg(method, c("full", "streaming"))

  # Compute p-values using selected method
  if (method == "full") {
    p_values <- compute_full_pvalues(
      observed_scores = observed_scores,
      run_permutation = run_permutation,
      n_permutations = n_permutations,
      n_cores = n_cores
    )
  } else {
    p_values <- compute_streaming_pvalues(
      observed_scores = observed_scores,
      run_permutation = run_permutation,
      n_permutations = n_permutations,
      n_cores = n_cores
    )
  }

  annotation$perm_pvalue <- p_values

  message(sprintf("P-values computed for %d annotations", n_annotations))
  message(sprintf("Annotations with p < 0.05: %d (%.1f%%)",
                  sum(p_values < 0.05, na.rm = TRUE),
                  100 * sum(p_values < 0.05, na.rm = TRUE) / n_annotations))

  return(annotation)
}

#' Compute p-values using full parallel method
#'
#' @description
#' Runs all permutations in parallel at once. Faster than streaming but uses
#' more memory since all null score matrices are held simultaneously.
#' On Unix systems, uses mclapply; on Windows uses PSOCK clusters.
#'
#' @param observed_scores Vector of observed annotation scores
#' @param run_permutation Function that runs a single permutation
#' @param n_permutations Number of permutations to run
#' @param n_cores Number of cores for parallel processing
#' @return Vector of p-values
#' @keywords internal
compute_full_pvalues <- function(observed_scores,
                                 run_permutation,
                                 n_permutations,
                                 n_cores) {
  n_annotations <- length(observed_scores)

  if (n_cores > 1) {
    if (.Platform$OS.type == "unix") {
      all_results <- parallel::mclapply(
        seq_len(n_permutations),
        run_permutation,
        mc.cores = n_cores,
        mc.preschedule = FALSE  # Better error handling for forked processes
      )
    } else {
      cl <- parallel::makeCluster(n_cores)
      on.exit(parallel::stopCluster(cl), add = TRUE)
      all_results <- parallel::parLapply(cl, seq_len(n_permutations), run_permutation)
      parallel::stopCluster(cl)
      on.exit(NULL)
    }

    # Check for errors (mclapply returns NULL or try-error on failure)
    failed <- sapply(all_results, function(x) {
      is.null(x) || inherits(x, "try-error") ||
        (is.list(x) && length(x) > 0 && inherits(x[[1]], "error"))
    })
    n_failed <- sum(failed)
    if (n_failed > 0) {
      warning(sprintf("%d of %d permutations failed. Using %d successful permutations.",
                      n_failed, n_permutations, n_permutations - n_failed))
      all_results <- all_results[!failed]
    }

    if (length(all_results) == 0) {
      stop("All permutations failed. Check that simple_annotation works correctly.")
    }

    n_successful <- length(all_results)
  } else {
    all_results <- lapply(seq_len(n_permutations), function(i) {
      if (i %% 100 == 0) {
        message(sprintf("Completed %d/%d permutations", i, n_permutations))
      }
      run_permutation(i)
    })
    n_successful <- n_permutations
  }

  message(sprintf("Completed %d/%d permutations", n_successful, n_permutations))

  # Count exceedances across all permutations (skip NULL results)
  exceedance_counts <- rep(0, n_annotations)
  for (null_scores in all_results) {
    if (!is.null(null_scores)) {
      exceedance_counts <- exceedance_counts + (null_scores >= observed_scores)
    }
  }

  # Calculate p-values with +1 correction (prevents p=0)
  # Use actual number of successful permutations
  p_values <- (exceedance_counts + 1) / (n_successful + 1)

  return(p_values)
}

#' Compute p-values using streaming method (memory efficient)
#'
#' @description
#' Processes permutations in chunks to minimize memory usage. On Unix systems,
#' uses mclapply for parallel processing; on Windows uses PSOCK clusters.
#'
#' @param observed_scores Vector of observed annotation scores
#' @param run_permutation Function that runs a single permutation
#' @param n_permutations Number of permutations to run
#' @param n_cores Number of cores for parallel processing
#' @return Vector of p-values
#' @keywords internal
compute_streaming_pvalues <- function(observed_scores,
                                      run_permutation,
                                      n_permutations,
                                      n_cores) {
  n_annotations <- length(observed_scores)
  exceedance_counts <- rep(0, n_annotations)
  n_successful <- 0
  n_failed_total <- 0

  if (n_cores > 1) {
    chunk_size <- min(50, n_permutations)

    for (chunk_start in seq(1, n_permutations, chunk_size)) {
      chunk_end <- min(chunk_start + chunk_size - 1, n_permutations)
      chunk_ids <- chunk_start:chunk_end

      if (.Platform$OS.type == "unix") {
        chunk_results <- parallel::mclapply(
          chunk_ids,
          run_permutation,
          mc.cores = n_cores,
          mc.preschedule = FALSE  # Better error handling for forked processes
        )
      } else {
        cl <- parallel::makeCluster(n_cores)
        on.exit(parallel::stopCluster(cl), add = TRUE)
        chunk_results <- parallel::parLapply(cl, chunk_ids, run_permutation)
        parallel::stopCluster(cl)
        on.exit(NULL)
      }

      # Check for errors in this chunk
      failed <- sapply(chunk_results, function(x) {
        is.null(x) || inherits(x, "try-error") ||
          (is.list(x) && length(x) > 0 && inherits(x[[1]], "error"))
      })
      n_failed_chunk <- sum(failed)
      n_failed_total <- n_failed_total + n_failed_chunk

      # Only count exceedances for successful permutations
      for (null_scores in chunk_results[!failed]) {
        if (!is.null(null_scores)) {
          exceedance_counts <- exceedance_counts + (null_scores >= observed_scores)
          n_successful <- n_successful + 1
        }
      }

      gc()
      message(sprintf("Completed %d/%d permutations", chunk_end, n_permutations))
    }

    if (n_failed_total > 0) {
      warning(sprintf("%d of %d permutations failed. Using %d successful permutations.",
                      n_failed_total, n_permutations, n_successful))
    }

    if (n_successful == 0) {
      stop("All permutations failed. Check that simple_annotation works correctly.")
    }
  } else {
    for (i in seq_len(n_permutations)) {
      null_scores <- run_permutation(i)
      if (!is.null(null_scores)) {
        exceedance_counts <- exceedance_counts + (null_scores >= observed_scores)
        n_successful <- n_successful + 1
      } else {
        n_failed_total <- n_failed_total + 1
      }

      if (i %% 100 == 0) {
        message(sprintf("Completed %d/%d permutations", i, n_permutations))
      }
    }

    if (n_failed_total > 0) {
      warning(sprintf("%d of %d permutations failed. Using %d successful permutations.",
                      n_failed_total, n_permutations, n_successful))
    }

    if (n_successful == 0) {
      stop("All permutations failed. Check that simple_annotation works correctly.")
    }
  }

  # Calculate p-values with +1 correction (prevents p=0)
  # Use actual number of successful permutations
  p_values <- (exceedance_counts + 1) / (n_successful + 1)

  return(p_values)
}
